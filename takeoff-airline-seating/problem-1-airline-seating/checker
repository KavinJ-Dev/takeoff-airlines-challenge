#!/opt/pwn.college/python

import unittest
import sys
sys.path.append("/challenge")

import modify_me


class TestTakeoffCleanSeats(unittest.TestCase):
    def test_basic_cleaning(self):
        seating_chart = [1, 2, 2, 3, 400, -5, 0]  # some invalid entries
        expected = [1, 2, 3]  # valid, deduplicated, sorted
        result = modify_me.takeoff_clean_seats(seating_chart)
        self.assertEqual(result, expected)

    def test_empty_list(self):
        seating_chart = []
        expected = []
        result = modify_me.takeoff_clean_seats(seating_chart)
        self.assertEqual(result, expected)

    def test_all_invalid(self):
        seating_chart = [0, -1, 301, 999]
        expected = []
        result = modify_me.takeoff_clean_seats(seating_chart)
        self.assertEqual(result, expected)

    def test_duplicates(self):
        seating_chart = [100, 100, 100]
        expected = [100]
        result = modify_me.takeoff_clean_seats(seating_chart)
        self.assertEqual(result, expected)


# Taken from https://stackoverflow.com/questions/13550039/how-to-use-python-unit-tests-in-self-contained-program
def run_tests(test_case):
    case = unittest.TestLoader().loadTestsFromTestCase(test_case)
    result = unittest.TestResult()
    case(result)
    if result.wasSuccessful():
        print("{0}/{0} tests passed!".format(result.testsRun))
        return True
    
    else:
        print("{0}/{1} tests failed!".format(len(result.failures), result.testsRun))
        for test, err in result.failures + result.errors:
            print("===================")
            print(test)
            print(err)
        
        print("===================")
        return False


if run_tests(TestTakeoffCleanSeats):
    print("All tests pass! Reading and displaying flag...")
    with open("/flag") as f:
        print(f.read())
else:
    print("Some tests fail. Please review the test cases and errors, then try again.")
